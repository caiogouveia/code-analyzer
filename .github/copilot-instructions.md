# Copilot Instructions

- **Product scope**: CLI + TUI utilities that estimate COCOMO II metrics, optionally correlate with Git history, and export JSON/PDF reports for software projects.
- **Python version**: Project targets Python 3.13; use `uv sync` (preferred) or `pip install -e .` to obtain dependencies from `pyproject.toml`/`uv.lock`.
- **Core modules**: `main.py` holds `CodeAnalyzer`, `CodeMetrics`, and `CocomoResults`; `git_analyzer.py` layers Git analytics (via `git log --shortstat`) and defines `IntegratedAnalyzer` plus dataclasses for commit stats; `tui_analyzer.py` builds a Textual UI that wraps `IntegratedAnalyzer` and exports JSON/PDF; `generate_pdf_report.py` consumes saved JSON to craft styled PDFs.
- **Reusability**: Prefer instantiating `CodeAnalyzer(Path)` and calling `analyze_directory()` + `calculate_cocomo2()` rather than duplicating directory walks; Git flows should go through `GitAnalyzer(repo_path)` or `IntegratedAnalyzer(repo_path)` to keep output shapes consistent with the TUI/export logic.
- **Language detection**: `LANGUAGE_EXTENSIONS` in `main.py` governs which files count toward LOC; adjust this map when adding language support. Comment detection is intentionally simple (prefix checks) and should stay fast—augment carefully to avoid slowing the scanner.
- **Ignored content**: `CodeAnalyzer.should_exclude` filters folders (node_modules, .venv, etc.) and extension suffixes; keep any new exclusion aligned with this helper so CLI, Git integration, and TUI stay in sync.
- **COCOMO coefficients**: `calculate_cocomo2` auto-selects organic/semi-detached/embedded modes based on KLOC. Preserve this branching so downstream insights (complexity labels, team sizing) remain meaningful.
- **Integrated metrics**: `IntegratedAnalyzer._calculate_integrated_metrics` ties raw LOC, Git stats, and productivity scoring together. When adding indicators, update both console tables in `git_analyzer.py` and TUI tables/insight generators to avoid mismatched views.
- **Console outputs**: CLI scripts format through Rich tables/panels; follow the existing style (box variants, emojis) for consistency, but keep heavy rendering isolated to `display_results` helpers.
- **TUI workflow**: `CocomoIIAnalyzerApp` (Textual) orchestrates welcome screen → async analysis → tab updates. Use `@work(thread=True)` for background tasks and `call_from_thread` for UI mutations; blocking calls in the main thread will freeze the interface.
- **TUI exports**: JSON export writes a full snapshot (`cocomo`, `git`, `integrated`). PDF export first materializes a temp JSON, calls `generate_pdf_report`, then removes the temp file—respect this pattern if extending formats.
- **PDF generation**: `generate_pdf_report.generate_pdf_report(json_path, pdf_path)` expects the same schema emitted by the TUI/CLI exports. ReportLab styles and Matplotlib charts are tuned to corporate branding; reuse the helper factories (`create_info_table`, `create_metric_box`) instead of re-styling ad hoc.
- **Reports folder**: Generated artifacts land under `reports/` with timestamps (`relatorio_<projeto>_<YYYYMMDD>_<HHMMSS>.json`). Preserve this naming convention so downstream tooling can glob reliably.
- **CLI usage**: Typical commands—`uv run python main.py [path]` for pure code metrics, `uv run python git_analyzer.py [path] [--export out.json]` for integrated results, `./run_tui.sh` or `uv run python tui_analyzer.py` for the Textual experience.
- **Git prerequisites**: Integrated flows require a Git repo with history (`.git` present). For CI or shallow clones, ensure `fetch-depth: 0`; otherwise `git log --shortstat` will underreport metrics.
- **Error handling**: Scripts exit early with Rich messages when no code files or no Git repo are detected. Maintain these guards to prevent zero-division paths in integrated metrics (e.g., repo age, total changes).
- **Testing reality**: There is no automated test suite—validate changes by re-running the CLI/TUI on sample projects or fixtures in `reports/`. Prefer creating short-lived JSON exports to sanity-check schema changes.
- **Localization**: Output is Portuguese-first (currency in BRL, messaging in pt-BR). Keep new strings localized and respect accents only if already present in surrounding text.
- **VS Code tips**: For Textual work, run `uv run textual run tui_analyzer.py` if you need live reload; otherwise `python tui_analyzer.py` suffices. Enable a non-interactive terminal when capturing Rich output snapshots for documentation.
- **Extending metrics**: When adding new tracked fields, update dataclasses (`CodeMetrics`, `GitMetrics`, `IntegratedMetrics`) and their `to_dict`/table renderers together, plus adjust JSON export to keep schema stable.
- **Dependency footprint**: `reportlab` and `matplotlib` are heavy; import them lazily only in modules that need them (already true). Avoid adding GUI dependencies outside Textual to keep the CLI light.
- **Run scripts**: `run_tui.sh` auto-activates `.venv` and ensures Textual is installed before launching. Mirror this setup if adding new entry-point scripts.
- **Version control**: Keep `uv.lock` in sync when bumping dependencies; document any new install steps in `README.md` and the quick-start docs (`QUICK_START.md`, `EXEMPLOS.md`).
